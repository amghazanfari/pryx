# Database Schema

Pryx uses **Postgres** with **GORM**. This document describes tables, relationships, indexes, migrations, and operational guidance.

## Overview

* Primary entities: `users`, `api_keys`, `models`
* Relationships:

  * `users (1) ── (N) api_keys`
  * `models` is independent registry for upstream LLM models

```
users ──< api_keys
models (standalone)
```

## Tables

### users

| column      | type        | constraints           | notes             |
| ----------- | ----------- | --------------------- | ----------------- |
| id          | bigint      | PK, generated by GORM |                   |
| email       | text        | UNIQUE                | identifier        |
| name        | text        |                       | display name      |
| is\_active  | bool        | DEFAULT true          | soft disable user |
| created\_at | timestamptz | DEFAULT now()         |                   |
| updated\_at | timestamptz | DEFAULT now()         |                   |

**GORM struct**: `internal/models/user.go`

---

### api\_keys

| column         | type        | constraints           | notes                             |
| -------------- | ----------- | --------------------- | --------------------------------- |
| id             | bigint      | PK                    |                                   |
| user\_id       | bigint      | FK → users(id), INDEX | owner                             |
| name           | text        |                       | label ("CLI", "Service A", etc.)  |
| prefix         | char(8)     | INDEX                 | first 8 chars of key              |
| hash           | char(64)    | UNIQUE                | sha256 of full key (no plaintext) |
| scopes         | text        |                       | CSV permissions                   |
| revoked        | bool        | DEFAULT false         | quick disable                     |
| last\_used\_at | timestamptz | NULLABLE              | set by middleware                 |
| created\_at    | timestamptz | DEFAULT now()         |                                   |
| updated\_at    | timestamptz | DEFAULT now()         |                                   |

**GORM struct**: `internal/models/apikey.go`

---

### models

| column      | type        | constraints   | notes                  |
| ----------- | ----------- | ------------- | ---------------------- |
| id          | bigint      | PK            |                        |
| name        | text        | INDEX         | display name           |
| model\_name | text        |               | e.g. `gpt-4o-mini`     |
| endpoint    | text        |               | upstream REST base URL |
| api\_key    | text        |               | optional upstream key  |
| created\_at | timestamptz | DEFAULT now() |                        |
| updated\_at | timestamptz | DEFAULT now() |                        |

**GORM struct**: `internal/models/models.go`

---

## Indexing Strategy

* `api_keys(hash)` UNIQUE for constant-time validation.
* `api_keys(prefix)` INDEX for quick lookup/logging & partial matches.
* `api_keys(user_id)` INDEX for admin listing per user.
* `users(email)` UNIQUE to prevent duplicates.
* `models(name)` INDEX for human-friendly searches.

## Migrations

Two mechanisms exist:

1. **AutoMigrate (dev)**

   * Enabled by `DB_AUTOMIGRATE=true` at service start.
   * Calls `db.AutoMigrateAll()` to ensure tables are present.

2. **Gormigrate (prod)**

   * `cmd/migrate` binary runs idempotent, ordered migrations.
   * Current migrations:

     * `0001_init_models` → creates `models`
     * `0002_users_apikeys` → creates `users`, `api_keys`

> Prefer the dedicated migrator in production to keep schema changes explicit and auditable.

### Example: adding a new column with gormigrate

```go
// inside a new migration file
func m0003() *gormigrate.Migration {
  return &gormigrate.Migration{
    ID: "0003_models_unique_model_name",
    Migrate: func(tx *gorm.DB) error {
      // example adding unique index
      return tx.Migrator().CreateIndex(&models.Model{}, "idx_models_model_name_unique")
    },
    Rollback: func(tx *gorm.DB) error {
      return tx.Migrator().DropIndex(&models.Model{}, "idx_models_model_name_unique")
    },
  }
}
```

## Configuration & Connection

Environment variables used (via `config.DBFromEnv()`):

* `POSTGRES_HOST` (default `localhost`)
* `POSTGRES_PORT` (default `5432`)
* `POSTGRES_USER` (default `postgres`)
* `POSTGRES_PASSWORD` (default empty)
* `POSTGRES_DB` (default `postgres`)
* `POSTGRES_SSLMODE` (default `disable`)
* `DB_TIMEZONE` (default `UTC`)

GORM connection tuning (see `internal/db/connection.go`):

* `MaxOpenConns = 20`
* `MaxIdleConns = 10`
* `ConnMaxLifetime = 30m`

## Example Queries

* **List active keys for a user**

```sql
SELECT id, prefix, scopes, revoked, last_used_at
FROM api_keys
WHERE user_id = $1 AND revoked = false
ORDER BY id DESC;
```

* **Revoke a key**

```sql
UPDATE api_keys SET revoked = true WHERE id = $1;
```

* **Find user by email**

```sql
SELECT id FROM users WHERE email = $1;
```

## Seeding & Bootstrap

* Create a user via `POST /admin/users`.
* Issue a key via `POST /admin/keys` and store the plaintext once.
* Optionally pre-load `models` rows for known upstreams.

## Backup & Restore

* **Backup**: `pg_dump -Fc -h $HOST -U $USER $DB > pryx.dump`
* **Restore**: `pg_restore -c -h $HOST -U $USER -d $DB pryx.dump`

Automate backups and verify restores in CI or a scheduled job.

## Operational Tips

* Never log full API keys; log `prefix`.
* Monitor for high 401/403 rates per `prefix` to detect abuse.
* Track `last_used_at` to prune stale keys.
* Use connection pooling and proper Postgres VACUUM/ANALYZE schedules.

## Future Extensions

* Add `teams` table and associate `api_keys.team_id` for multi-tenant RBAC.
* Add `completions` table to meter usage (tokens, latency, status) per key.
* Optional `model_access` join table for per-key allowlists.
